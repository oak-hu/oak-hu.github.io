<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anisogamy Evolution Simulation</title>
    <style>
        body {
            font-family: Garamond, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #022520;
	    color: #022520;
        }
        .controls {
            background: #d4b79a;
            padding: 20px 20px 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 180px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 200px;
        }
        .value-display {
            display: inline-block;
            width: 100px;
            text-align: right;
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            background: #018574;
            color: #022520;
	    font-family: inherit;
	    font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #014d43;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #stats {
            background: #d4b79a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            background: #d4b79a;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .warning {
            color: #022520;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1 style="color:#a5663e;">Evolving Anisogamy</h1>
    <h2 style="color:#a5663e;">Based on Maire et al. 2001</h2>
    
    <div class="controls">
        <div class="control-group">
            <label>Discretisation Density:</label>
            <input type="range" id="resolution" min="100" max="1000" step="100" value="100">
            <span class="value-display" id="resolutionValue">100</span>
            <div class="warning" id="resolutionWarning" style="display:none;">Higher density may impact performance</div>
        </div>
        <div class="control-group">
            <label>Population Size:</label>
            <input type="range" id="populationSize" min="10" max="1000" step="10" value="500">
            <span class="value-display" id="populationSizeValue">500</span>
        </div>
        <div class="control-group">
            <label>Initial Gamete Size:</label>
            <input type="range" id="startingSize" min="0.01" max="1.00" step="0.01" value="0.5">
            <span class="value-display" id="startingSizeValue">0.50</span>
        </div>
        <div class="control-group">
            <label>Mutation Probability:</label>
            <input type="range" id="mutationProb" min="0.01" max="1" step="0.01" value="0.1">
            <span class="value-display" id="mutationProbValue">0.10</span>
        </div>
        <div class="control-group">
            <label>Max Mutation Size:</label>
            <input type="range" id="mutationSize" min="0.01" max="0.1" step="0.01" value="0.01">
            <span class="value-display" id="mutationSizeValue">0.01</span>
        </div>
        <div class="control-group">
            <button id="startBtn">Start</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>
    
    <div id="stats">
        <strong>Generation:</strong> <span id="generation">0</span> | 
        <strong>Mean Gamete Size:</strong> <span id="meanSize">-</span> | 
        <strong>Std Dev:</strong> <span id="stdDev">-</span> |
        <strong>FPS:</strong> <span id="fps">-</span>
    </div>
    
    <canvas id="histogram" width="900" height="400"></canvas>

    <script>
        const MIN_SIZE = 0.001;
        const MAX_SIZE = 3.00;
        const HISTOGRAM_BINS = 150;
        
        let resolution = 4000;
        let stepSize = (MAX_SIZE) / resolution;
        let sizeSteps = resolution + 1;
        let survivalTable = null;
        
        let populationSize = 500;
        let population = [];
        let generation = 0;
        let running = false;
        let animationId = null;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        
        const canvas = document.getElementById('histogram');
        const ctx = canvas.getContext('2d');
        
        // UI elements
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const resolutionSlider = document.getElementById('resolution');
        const populationSizeSlider = document.getElementById('populationSize');
        const startingSizeSlider = document.getElementById('startingSize');
        const mutationProbSlider = document.getElementById('mutationProb');
        const mutationSizeSlider = document.getElementById('mutationSize');
        
        // Update displayed values
        resolutionSlider.oninput = () => {
            const res = parseInt(resolutionSlider.value);
            document.getElementById('resolutionValue').textContent = res;
            document.getElementById('resolutionWarning').style.display = res > 500 ? 'block' : 'none';
        };
        
        populationSizeSlider.oninput = () => {
            document.getElementById('populationSizeValue').textContent = populationSizeSlider.value;
        };
        
        startingSizeSlider.oninput = () => {
            document.getElementById('startingSizeValue').textContent = parseFloat(startingSizeSlider.value).toFixed(2);
        };
        
        mutationProbSlider.oninput = () => {
            const prob = parseFloat(mutationProbSlider.value);
            document.getElementById('mutationProbValue').textContent = prob.toFixed(2);
        };
        
        mutationSizeSlider.oninput = () => {
            document.getElementById('mutationSizeValue').textContent = mutationSizeSlider.value;
        };
        
        // Round to nearest step
        function roundToStep(value) {
            return Math.round((value - MIN_SIZE) / stepSize) * stepSize + MIN_SIZE;
        }
        
        // Convert size to index in lookup table
        function sizeToIndex(size) {
            return Math.min(sizeSteps - 1, Math.max(0, Math.round((size - MIN_SIZE) / stepSize)));
        }
        
        // Initialize lookup table
        function initializeLookupTable() {
            resolution = 4 * parseInt(resolutionSlider.value);
            stepSize = (MAX_SIZE - MIN_SIZE) / resolution;
            sizeSteps = resolution + 1;
            
            console.log(`Initializing ${sizeSteps}x${sizeSteps} lookup table...`);
            survivalTable = new Float32Array(sizeSteps * sizeSteps);
            
            for (let i = 0; i < sizeSteps; i++) {
                for (let j = 0; j < sizeSteps; j++) {
                    const size1 = MIN_SIZE + i * stepSize;
                    const size2 = MIN_SIZE + j * stepSize;
                    const zygoteSize = size1 + size2;
                    const survival = Math.min(1, Math.max(0, 1 - 1.05 * Math.exp(-zygoteSize * zygoteSize)));
                    survivalTable[i * sizeSteps + j] = survival;
                }
            }
            console.log('Lookup table initialized');
        }
        
        // Get survival from lookup table
        function getSurvival(size1, size2) {
            const idx1 = sizeToIndex(size1);
            const idx2 = sizeToIndex(size2);
            return survivalTable[idx1 * sizeSteps + idx2];
        }
        
        // Create individual
        function createIndividual(allele1, allele2) {
            // Round alleles to nearest step
            allele1 = roundToStep(allele1);
            allele2 = roundToStep(allele2);
            return {
                allele1: allele1,
                allele2: allele2,
                gameteSize: (allele1 + allele2) / 2
            };
        }
        
        // Mutate allele with probability
        function mutate(allele) {
            const mutProb = parseFloat(mutationProbSlider.value);
            if (Math.random() < mutProb) {
                const mutSize = parseFloat(mutationSizeSlider.value);
                // Add or subtract mutation size * step size
                const mutation = 2 * (0.5 - Math.random()) * mutSize;
                const newAllele = allele + mutation;
                return Math.min(MAX_SIZE, Math.max(MIN_SIZE, roundToStep(newAllele)));
            }
            return allele;
        }
        
        // Pick random allele from parent
        function pickRandomly(allele1, allele2) {
            return Math.random() < 0.5 ? allele1 : allele2;
        }
        
        // Initialize population
        function initializePopulation() {
            populationSize = parseInt(populationSizeSlider.value);
            const startSize = roundToStep(parseFloat(startingSizeSlider.value));
            population = [];
            for (let i = 0; i < populationSize; i++) {
                population.push(createIndividual(startSize, startSize));
            }
            generation = 0;
        }
        
        // Calculate mating weights using lookup table
        function calculateWeights() {
            const weights = [];
            const pairs = [];
            
            for (let n = 0; n < populationSize; n++) {
                for (let m = n; m < populationSize; m++) {
                    const indN = population[n];
                    const indM = population[m];
                    const survival = getSurvival(indN.gameteSize, indM.gameteSize);
                    let weight = survival / (indN.gameteSize * indM.gameteSize);
                    
                    // Halve weight for self-pairing
                    if (n === m) {
                        weight /= 2;
                    }
                    
                    weights.push(weight);
                    pairs.push([n, m]);
                }
            }
            
            // Build cumulative weights for faster sampling
            const cumWeights = new Float32Array(weights.length);
            cumWeights[0] = weights[0];
            for (let i = 1; i < weights.length; i++) {
                cumWeights[i] = cumWeights[i - 1] + weights[i];
            }
            
            return { cumWeights, pairs, totalWeight: cumWeights[cumWeights.length - 1] };
        }
        
        // Sample pair using binary search on cumulative weights
        function samplePair(cumWeights, pairs, totalWeight) {
            const random = Math.random() * totalWeight;
            
            // Binary search
            let left = 0;
            let right = cumWeights.length - 1;
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                if (cumWeights[mid] < random) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            return pairs[left];
        }
        
        // Create next generation
        function nextGeneration() {
            const { cumWeights, pairs, totalWeight } = calculateWeights();
            const newPopulation = [];
            
            for (let i = 0; i < populationSize; i++) {
                const [nIdx, mIdx] = samplePair(cumWeights, pairs, totalWeight);
                const indN = population[nIdx];
                const indM = population[mIdx];
                
                const allele1 = mutate(pickRandomly(indN.allele1, indN.allele2));
                const allele2 = mutate(pickRandomly(indM.allele1, indM.allele2));
                
                newPopulation.push(createIndividual(allele1, allele2));
            }
            
            population = newPopulation;
            generation++;
        }
        
        // Calculate statistics
        function calculateStats() {
            const sizes = population.map(ind => ind.gameteSize);
            const mean = sizes.reduce((a, b) => a + b, 0) / sizes.length;
            const variance = sizes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / sizes.length;
            const stdDev = Math.sqrt(variance);
            
            return { mean, stdDev };
        }
        
        // Draw histogram
        function drawHistogram() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create bins
            const bins = new Array(HISTOGRAM_BINS).fill(0);
            const binWidth = (MAX_SIZE / 2 - MIN_SIZE) / HISTOGRAM_BINS;
            
            population.forEach(ind => {
                const binIndex = Math.floor((ind.gameteSize - MIN_SIZE) / binWidth);
                if (binIndex >= 0 && binIndex < HISTOGRAM_BINS) {
                    bins[binIndex]++;
                }
            });
            
            // Draw axes
            ctx.strokeStyle = '#022520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 350);
            ctx.lineTo(850, 350);
            ctx.moveTo(50, 50);
            ctx.lineTo(50, 350);
            ctx.stroke();
            
            // Draw bars
            const barWidth = 800 / HISTOGRAM_BINS;
            const maxCount = populationSize;
            
            ctx.fillStyle = '#018574';
            bins.forEach((count, i) => {
                const barHeight = (count / maxCount) * 300;
                const x = 50 + i * barWidth;
                const y = 350 - barHeight;
                ctx.fillRect(x, y, barWidth + 1, barHeight);
            });
            
            // Labels
            ctx.fillStyle = '#022520';
            ctx.font = '12px Garamond';
            ctx.textAlign = 'center';
            
            // X-axis labels
            for (let i = 0; i <= 6; i++) {
                const value = MIN_SIZE + (MAX_SIZE / 2 - MIN_SIZE) * i / 6;
                const x = 50 + 800 * i / 6;
                ctx.fillText(value.toFixed(2), x, 370);
            }
            
            // Y-axis labels (dynamic based on population size)
            ctx.textAlign = 'right';
            const yStep = Math.ceil(populationSize / 5);
            for (let i = 0; i <= 5; i++) {
                const value = i * yStep;
                const y = 350 - (i * 300 / 5);
                ctx.fillText(value, 40, y + 5);
            }
            
            // Axis titles
            ctx.font = '14px Garamond';
            ctx.textAlign = 'center';
            ctx.fillText('Gamete Size', 450, 395);
            
            ctx.save();
            ctx.translate(15, 200);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }
        
        // Update display
        function updateDisplay() {
            const stats = calculateStats();
            document.getElementById('generation').textContent = generation;
            document.getElementById('meanSize').textContent = stats.mean.toFixed(2);
            document.getElementById('stdDev').textContent = stats.stdDev.toFixed(2);
            document.getElementById('fps').textContent = fps.toFixed(1);
            drawHistogram();
        }
        
        // Animation loop
        function animate(currentTime) {
            if (running) {
                // Calculate FPS
                frameCount++;
                if (currentTime - lastFrameTime >= 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastFrameTime = currentTime;
                }
                
                nextGeneration();
                updateDisplay();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Event handlers
        startBtn.onclick = () => {
            running = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            resolutionSlider.disabled = true;
            populationSizeSlider.disabled = true;
            startingSizeSlider.disabled = true;
            frameCount = 0;
            lastFrameTime = performance.now();
            animate(lastFrameTime);
        };
        
        pauseBtn.onclick = () => {
            running = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        };
        
        resetBtn.onclick = () => {
            running = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            resolutionSlider.disabled = false;
            populationSizeSlider.disabled = false;
            startingSizeSlider.disabled = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            initializeLookupTable();
            initializePopulation();
            updateDisplay();
        };
        
        // Handle resolution changes
        resolutionSlider.onchange = () => {
            if (!running) {
                initializeLookupTable();
                initializePopulation();
                updateDisplay();
            }
        };
        
        // Initialize
        initializeLookupTable();
        initializePopulation();
        updateDisplay();
    </script>
</body>
</html>